"""
ARQUIVO DE BACKUP HIST√ìRICO - Home.py Legacy
============================================
Este arquivo cont√©m a vers√£o anterior do Home.py antes da migra√ß√£o obrigat√≥ria 
para o Backend V2. Mantido apenas para refer√™ncia hist√≥rica.

N√ÉO UTILIZAR EM PRODU√á√ÉO - Sistema atualizado usa Backend V2 obrigat√≥rio.
Data do backup: Junho 2025
"""

import pandas as pd
import plotly.express as px
import streamlit as st
import time
import os
import json
import hashlib

from componentes.profile_pic_component import boas_vindas_com_foto
from database import get_connection, create_tables, remover_usuario, get_user_role
from utils.config import ENABLE_CACHE, get_current_user, get_descricoes_personalizadas_file, get_transacoes_excluidas_file
from utils.exception_handler import ExceptionHandler
from utils.filtros import filtro_data, filtro_categorias, aplicar_filtros
from utils.formatacao import formatar_valor_monetario, formatar_df_monetario, calcular_resumo_financeiro
from utils.ofx_reader import OFXReader

# Importa√ß√µes do novo backend V2
from utils.database_manager_v2 import DatabaseManager
from utils.repositories_v2 import RepositoryManager
from services.transacao_service_v2 import TransacaoService
from utils.database_monitoring import DatabaseMonitor

# Importa√ß√µes de seguran√ßa
from security.auth.authentication import SecureAuthentication
try:
    from security.auth.rate_limiter import RateLimiter  # type: ignore
except ImportError:
    # Fallback to inline RateLimiter if import fails
    class RateLimiter:
        def __init__(self):
            self.MAX_LOGIN_ATTEMPTS = 5
            self.LOGIN_WINDOW_MINUTES = 15
            self._attempts_by_ip = {}
            self._attempts_by_user = {}
        
        def check_rate_limit(self, ip_address, username=None):
            return True  # Simplified for now
        
        def record_attempt(self, ip_address, username=None, success=False):
            pass  # Simplified for now

# Configura√ß√µes da p√°gina
st.set_page_config(
    page_title="Richness - Dashboard", 
    layout="wide",
    initial_sidebar_state="expanded"
)

# Verificar autentica√ß√£o
def verificar_autenticacao():
    if 'authenticated' not in st.session_state or not st.session_state['authenticated']:
        mostrar_formulario_login()
        st.stop()

def mostrar_formulario_login():
    """Exibe formul√°rio de login na p√°gina Home"""
    
    # Configurar layout para centralizar o login
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        st.markdown("---")
        st.markdown("## üîê Login")
        st.markdown("Para acessar o dashboard, fa√ßa login com suas credenciais:")
        
        # Formul√°rio de login
        with st.form("login_form", clear_on_submit=False):
            usuario = st.text_input(
                "üë§ Usu√°rio",
                placeholder="Digite seu nome de usu√°rio",
                help="Nome de usu√°rio cadastrado no sistema"
            )
            
            senha = st.text_input(
                "üîí Senha",
                type="password",
                placeholder="Digite sua senha",
                help="Senha do seu usu√°rio"
            )
            
            col_login, col_register = st.columns(2)
            
            with col_login:
                login_button = st.form_submit_button(
                    "üöÄ Entrar",
                    use_container_width=True,
                    type="primary"
                )
            
            with col_register:
                if st.form_submit_button(
                    "üìù Criar Conta",
                    use_container_width=True
                ):
                    st.switch_page("pages/Cadastro.py")
            
            # Processar login            if login_button:
                if not usuario or not senha:
                    st.error("‚ùå Por favor, preencha todos os campos!")
                else:
                    try:
                        import sqlite3
                        import hashlib
                        
                        # Obter IP do cliente (fallback para localhost)  
                        client_ip = st.session_state.get('client_ip', '127.0.0.1')
                        
                        # Conex√£o direta com o banco para verificar credenciais
                        conn = sqlite3.connect('richness.db')
                        cur = conn.cursor()
                        
                        cur.execute('SELECT usuario, senha FROM usuarios WHERE usuario = ?', (usuario,))
                        user_record = cur.fetchone()
                        
                        if user_record:
                            stored_username, stored_hash = user_record
                            
                            # Verificar se √© hash SHA-256 (64 caracteres)
                            if len(stored_hash) == 64:
                                # Hash SHA-256 simples
                                provided_hash = hashlib.sha256(senha.encode()).hexdigest()
                                senha_valida = (provided_hash == stored_hash)
                            else:
                                # Tentar com bcrypt
                                try:
                                    import bcrypt
                                    senha_valida = bcrypt.checkpw(senha.encode('utf-8'), stored_hash.encode('utf-8'))
                                except:
                                    senha_valida = False
                            
                            if senha_valida:
                                resultado = {
                                    'success': True,
                                    'message': 'Login realizado com sucesso',
                                    'username': usuario
                                }
                            else:
                                resultado = {
                                    'success': False,
                                    'message': 'Usu√°rio ou senha incorretos'
                                }
                        else:
                            resultado = {
                                'success': False,
                                'message': 'Usu√°rio n√£o encontrado'
                            }
                        
                        conn.close()
                        
                        if resultado['success']:
                            # Login bem-sucedido - configurar sess√£o
                            st.session_state['authenticated'] = True
                            st.session_state['autenticado'] = True
                            st.session_state['usuario'] = usuario
                            st.session_state['session_id'] = resultado.get('session_id', '')
                            
                            st.success("‚úÖ Login realizado com sucesso!")
                            st.info("üîÑ Redirecionando para o dashboard...")
                            time.sleep(1)
                            st.rerun()
                            
                        else:
                            # Login falhou
                            message = resultado.get('message', 'Erro na autentica√ß√£o')
                            st.error(f"‚ùå {message}")
                              # Verificar se a conta est√° bloqueada
                            if resultado.get('account_locked'):
                                st.warning("‚ö†Ô∏è Sua conta foi bloqueada por seguran√ßa. Contate o administrador.")
                            elif resultado.get('rate_limited'):
                                st.warning("‚ö†Ô∏è Muitas tentativas de login. Aguarde alguns minutos.")
                                
                    except Exception as e:
                        st.error("‚ùå Erro interno do sistema. Tente novamente.")
        
        # Links √∫teis
        st.markdown("---")
        
        # Informa√ß√µes adicionais
        with st.expander("‚ÑπÔ∏è Precisa de ajuda?"):
            st.write("""
            **Primeiro acesso?**
            - Clique em "Criar Conta" para se cadastrar
            - Preencha seus dados e crie uma senha segura
            
            **Esqueceu sua senha?**
            - Entre em contato com o administrador
            - Mantenha suas credenciais em local seguro
            
            **Problemas t√©cnicos?**
            - Verifique sua conex√£o com a internet
            - Limpe o cache do navegador
            - Tente novamente em alguns minutos
            """)
        
        # Informa√ß√£o de seguran√ßa
        st.markdown("---")
        st.markdown(
            "üîí **Suas informa√ß√µes est√£o protegidas** com criptografia "
            "e pol√≠ticas de seguran√ßa avan√ßadas."
        )

verificar_autenticacao()

# Criar tabelas do banco de dados
create_tables()

# Inicializar novo backend V2
@st.cache_resource
def init_backend_v2():
    """Inicializa o novo backend com cache para melhor performance"""
    try:
        # Inicializar componentes do novo backend
        db_manager = DatabaseManager()
        repository_manager = RepositoryManager(db_manager)
        transacao_service = TransacaoService()
        monitor = DatabaseMonitor(db_manager)
        
        return {
            'db_manager': db_manager,
            'repository_manager': repository_manager,
            'transacao_service': transacao_service,
            'monitor': monitor
        }
    except Exception as e:
        # Fallback para backend antigo em caso de erro
        st.warning(f"‚ö†Ô∏è Usando backend legado: {str(e)}")
        return None

# Inicializar backend
backend_v2 = init_backend_v2()

# Obter usu√°rio da sess√£o
usuario = st.session_state.get('usuario', 'default')

# Boas-vindas com foto de perfil
if usuario:
    boas_vindas_com_foto(usuario)

# T√≠tulo principal
st.title("üè† Dashboard Financeiro")

# Se√ß√£o de status do sistema (expans√≠vel)
with st.expander("üîß Status do Sistema", expanded=False):
    if backend_v2:
        # Verificar se realmente est√° usando V2 ou fallback
        usando_v2 = False
        try:
            # Fazer um teste simples para ver se o V2 est√° funcionando
            transacao_service = backend_v2['transacao_service']
            test_df = transacao_service.listar_transacoes_usuario(usuario)
            usando_v2 = not test_df.empty
        except:
            usando_v2 = False
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if usando_v2:
                st.metric(
                    "üöÄ Backend", 
                    "V2 (Ativo)", 
                    "‚úÖ Funcionando"
                )
            else:
                st.metric(
                    "üöÄ Backend", 
                    "Legado", 
                    "‚ö†Ô∏è Fallback"
                )
        
        with col2:
            if usando_v2:
                # Verificar sa√∫de do banco
                try:
                    monitor = backend_v2['monitor']
                    health_info = monitor.get_system_health()
                    status = "‚úÖ Saud√°vel" if health_info.get('healthy', False) else "‚ö†Ô∏è Aten√ß√£o"
                    st.metric("üíó Sa√∫de DB", status)
                except:
                    st.metric("üíó Sa√∫de DB", "‚ùì Verificando")
            else:
                st.metric("üíó Sistema", "üìÅ Arquivos OFX")
        
        with col3:
            if usando_v2:
                # Performance do cache
                try:
                    db_manager = backend_v2['db_manager']
                    cache_stats = db_manager.get_cache_stats()
                    hit_rate = cache_stats.get('hit_rate', 0)
                    st.metric("‚ö° Cache Hit", f"{hit_rate:.1f}%")
                except:
                    st.metric("‚ö° Cache Hit", "N/A")
            else:
                st.metric("‚ö° Modo", "üîÑ Compatibilidade")
                
        # Mostrar m√©tricas detalhadas se solicitado
        if st.checkbox("üìä Mostrar m√©tricas detalhadas"):
            if usando_v2:
                try:
                    monitor = backend_v2['monitor']
                    metrics = monitor.get_performance_metrics()
                    
                    col1, col2 = st.columns(2)
                    with col1:
                        st.json({
                            "Conex√µes ativas": metrics.get('active_connections', 0),
                            "Queries executadas": metrics.get('total_queries', 0),
                            "Tempo m√©dio query": f"{metrics.get('avg_query_time', 0):.2f}ms"
                        })
                    
                    with col2:
                        st.json({
                            "Cache size": f"{metrics.get('cache_size', 0)} entries",
                            "Memory usage": f"{metrics.get('memory_usage', 0):.1f}MB",
                            "Uptime": f"{metrics.get('uptime', 0):.1f}s"
                        })
                except Exception as e:
                    st.error(f"Erro ao carregar m√©tricas: {e}")
            else:
                st.info("""
                **Sistema em Modo Legado**
                
                ‚úÖ **Funcionando perfeitamente**:
                - Dados carregados de arquivos OFX
                - Todas as funcionalidades dispon√≠veis
                - Performance otimizada com cache
                
                üîÑ **Pr√≥ximos passos**:
                - Migra√ß√£o autom√°tica para V2 em andamento
                - Dados ser√£o preservados
                - Experi√™ncia melhorada em breve
                """)
    else:
        st.warning("üîÑ Usando backend legado - considere migrar para V2")

st.markdown("---")

# Cache do OFX Reader
@st.cache_resource(ttl=300)
def get_ofx_reader():
    usuario_atual = get_current_user()
    return OFXReader(usuario_atual)

@st.cache_data(ttl=600)
def carregar_dados_home(usuario, force_refresh=False):
    """Carrega dados essenciais para a Home com cache otimizado - Nova vers√£o com Backend V2"""
    def _load_data():
        # Inicializar vari√°veis
        df_extratos = pd.DataFrame()
        df_cartoes = pd.DataFrame()
        df_ofx = pd.DataFrame()
        df_transacoes = pd.DataFrame()
        dados_v2_ok = False
        
        # Tentar usar o novo backend V2 primeiro
        if backend_v2:
            try:
                transacao_service = backend_v2['transacao_service']
                
                # Carregar todas as transa√ß√µes do usu√°rio
                df_transacoes = transacao_service.listar_transacoes_usuario(usuario)
                
                if not df_transacoes.empty:
                    # Calcular saldos por origem usando o novo servi√ßo
                    saldos_info = transacao_service.calcular_saldos_por_origem(usuario)
                    
                    # Converter para formato esperado pelo frontend
                    saldos_formatted = {}
                    for origem, saldo_data in saldos_info.items():
                        saldos_formatted[origem] = {
                            'saldo': saldo_data.get('saldo_total', 0),
                            'tipo': 'credit_card' if 'fatura' in origem.lower() or 'nubank' in origem.lower() else 'checking'
                        }
                    
                    dados_v2_ok = True
                    st.success("‚úÖ Usando Backend V2 - dados carregados com sucesso!")
                    return saldos_formatted, df_transacoes
                    
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Erro no backend V2: {str(e)}")
        
        # Se V2 n√£o funcionou ou n√£o retornou dados, usar backend legado
        if not dados_v2_ok:
            # Notifica√ß√£o clara e informativa sobre o fallback
            with st.container():
                # Banner principal de fallback
                st.warning("‚ö†Ô∏è **Sistema em Modo de Compatibilidade (Legado)**")
                
                # Informa√ß√µes detalhadas em colunas
                col1, col2 = st.columns([2, 1])
                
                with col1:
                    st.info("""
                    ÔøΩ **Informa√ß√µes do Sistema**
                    
                    üîÑ **Status atual**: Utilizando dados do sistema legado  
                    üìÅ **Fonte dos dados**: Arquivos OFX nas pastas extratos/ e faturas/  
                    üìä **Funcionalidades**: Dashboard completo dispon√≠vel  
                    ‚ö° **Performance**: Modo otimizado com cache  
                    üîß **Pr√≥ximo passo**: Migra√ß√£o para Backend V2 em andamento
                    """)
                
                with col2:
                    # Bot√µes de a√ß√£o
                    if st.button("üîÑ Tentar Backend V2", key="retry_v2", help="Tentar conectar ao novo sistema"):
                        st.cache_data.clear()
                        st.rerun()
                    
                    if st.button("üßπ Limpar Cache", key="clear_cache", help="Limpar cache e recarregar dados"):
                        st.cache_data.clear()
                        st.rerun()
                
                # Status t√©cnico em expand√≠vel
                with st.expander("üîß Detalhes T√©cnicos", expanded=False):
                    st.markdown("""
                    **Por que estou vendo esta mensagem?**
                    - O backend V2 ainda est√° sendo configurado ou migrado
                    - Seus dados est√£o seguros no sistema legado
                    - Todas as funcionalidades continuam dispon√≠veis
                    
                    **O que posso fazer?**
                    - ‚úÖ Continuar usando normalmente o dashboard
                    - ‚úÖ Adicionar/editar transa√ß√µes
                    - ‚úÖ Visualizar relat√≥rios e gr√°ficos
                    - ‚úÖ Gerenciar categorias
                    
                    **Quando o V2 estar√° dispon√≠vel?**
                    - A migra√ß√£o √© autom√°tica e transparente
                    - Seus dados ser√£o preservados durante a transi√ß√£o
                    - Voc√™ ser√° notificado quando o upgrade estiver completo
                    """)
            
            st.markdown("---")
            
            ofx_reader = get_ofx_reader()
            
            # Se force_refresh for True, limpar cache
            if force_refresh:
                ofx_reader.limpar_cache()
            
            # Carregar dados dos arquivos OFX
            df_extratos = ofx_reader.buscar_extratos()
            df_cartoes = ofx_reader.buscar_cartoes()
            
            # Mostrar estat√≠sticas dos dados carregados
            total_extratos = len(df_extratos)
            total_cartoes = len(df_cartoes)
            total_geral = total_extratos + total_cartoes
            
            if total_geral > 0:
                # Estat√≠sticas detalhadas com m√©tricas visuais
                st.success("‚úÖ **Dados carregados com sucesso do sistema legado!**")
                
                # M√©tricas em colunas
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric(
                        "üè¶ Extratos",
                        f"{total_extratos}",
                        help="Transa√ß√µes de conta corrente"
                    )
                
                with col2:
                    st.metric(
                        "üí≥ Cart√µes", 
                        f"{total_cartoes}",
                        help="Transa√ß√µes de cart√£o de cr√©dito"
                    )
                
                with col3:
                    st.metric(
                        "üìà Total",
                        f"{total_geral}",
                        help="Total de transa√ß√µes carregadas"
                    )
                
                with col4:
                    # Calcular per√≠odo de dados se houver transa√ß√µes
                    if total_geral > 0:
                        df_temp = pd.concat([df_extratos, df_cartoes], ignore_index=True) if not df_extratos.empty or not df_cartoes.empty else pd.DataFrame()
                        if not df_temp.empty and 'Data' in df_temp.columns:
                            df_temp['Data'] = pd.to_datetime(df_temp['Data'], errors='coerce')
                            data_mais_antiga = df_temp['Data'].min()
                            data_mais_recente = df_temp['Data'].max()
                            if pd.notna(data_mais_antiga) and pd.notna(data_mais_recente):
                                periodo_dias = (data_mais_recente - data_mais_antiga).days
                                st.metric(
                                    "üìÖ Per√≠odo",
                                    f"{periodo_dias} dias",
                                    help=f"De {data_mais_antiga.strftime('%d/%m/%Y')} at√© {data_mais_recente.strftime('%d/%m/%Y')}"
                                )
                            else:
                                st.metric("üìÖ Per√≠odo", "N/A")
                        else:
                            st.metric("üìÖ Per√≠odo", "N/A")
                    else:
                        st.metric("üìÖ Per√≠odo", "N/A")
                
                # Informa√ß√µes adicionais em expand√≠vel
                with st.expander("ÔøΩ Detalhes dos Dados Carregados", expanded=False):
                    if total_extratos > 0:
                        st.write(f"**Extratos banc√°rios**: {total_extratos} transa√ß√µes encontradas")
                    if total_cartoes > 0:
                        st.write(f"**Faturas de cart√£o**: {total_cartoes} transa√ß√µes encontradas")
                    
                    # Mostrar origens dos dados
                    if not df_extratos.empty and 'Origem' in df_extratos.columns:
                        origens_extratos = df_extratos['Origem'].unique()
                        st.write(f"**Origens de extratos**: {', '.join(origens_extratos)}")
                    
                    if not df_cartoes.empty and 'Origem' in df_cartoes.columns:
                        origens_cartoes = df_cartoes['Origem'].unique()
                        st.write(f"**Origens de cart√µes**: {', '.join(origens_cartoes)}")
            else:
                st.error("‚ùå Nenhum dado encontrado nos arquivos OFX. Verifique se os arquivos est√£o na pasta correta.")
                st.stop()
            
            # Combinar extratos e cart√µes (apenas no fallback)
            df_ofx = pd.concat([df_extratos, df_cartoes], ignore_index=True) if not df_extratos.empty or not df_cartoes.empty else pd.DataFrame()
        
            # Carregar transa√ß√µes manuais (para compatibilidade com sistema legado)
            transacoes_manuais_file = "transacoes_manuais.json"
            df_manuais = pd.DataFrame()
            
            if os.path.exists(transacoes_manuais_file):
                try:
                    import json
                    with open(transacoes_manuais_file, 'r', encoding='utf-8') as f:
                        transacoes_manuais = json.load(f)
                    
                    if transacoes_manuais:
                        dados_manuais = []
                        for transacao in transacoes_manuais:
                            dados_manuais.append({
                                "Data": pd.to_datetime(transacao["data"]),
                                "Descri√ß√£o": transacao["descricao"],
                                "Valor": transacao["valor"],
                                "Categoria": transacao["categoria"],
                                "Tipo": transacao["tipo"],
                                "Origem": transacao["origem"],
                                "Id": transacao["id"],
                                "tipo_pagamento": transacao.get("tipo_pagamento", "Esp√©cie"),
                                "data_criacao": transacao.get("data_criacao", "")
                            })
                        
                        df_manuais = pd.DataFrame(dados_manuais)
                except:
                    pass  # Em caso de erro, continuar sem transa√ß√µes manuais
            
            # Combinar transa√ß√µes OFX e manuais
            if not df_ofx.empty and not df_manuais.empty:
                df = pd.concat([df_ofx, df_manuais], ignore_index=True)
            elif not df_ofx.empty:
                df = df_ofx
            elif not df_manuais.empty:
                df = df_manuais
            else:
                df = pd.DataFrame()
        else:
            # Se chegou aqui, V2 funcionou - usar os dados do V2
            df = df_transacoes
        
        # Pr√©-processamento m√≠nimo
        if not df.empty:
            df["Data"] = pd.to_datetime(df["Data"])
            df["Valor"] = pd.to_numeric(df["Valor"], errors="coerce")
            
            # Aplicar categoriza√ß√µes personalizadas do usu√°rio (MESMO C√ìDIGO DA P√ÅGINA GERENCIAR_TRANSACOES)
            cache_categorias_file = "cache_categorias_usuario.json"
            if os.path.exists(cache_categorias_file):
                try:
                    import json
                    with open(cache_categorias_file, 'r', encoding='utf-8') as f:
                        cache = json.load(f)
                    
                    def aplicar_categoria_personalizada(row):
                        descricao_normalizada = row["Descri√ß√£o"].lower().strip()
                        if descricao_normalizada in cache:
                            return cache[descricao_normalizada]
                        return row.get("Categoria", "Outros")
                    
                    df["Categoria"] = df.apply(aplicar_categoria_personalizada, axis=1)
                except:
                    pass  # Em caso de erro, manter categoriza√ß√µes originais
            
            # Aplicar filtro de transa√ß√µes exclu√≠das
            transacoes_excluidas_file = get_transacoes_excluidas_file()
            if os.path.exists(transacoes_excluidas_file):
                try:
                    import json
                    import hashlib
                    with open(transacoes_excluidas_file, 'r', encoding='utf-8') as f:
                        transacoes_excluidas = json.load(f)
                    
                    if transacoes_excluidas:
                        def gerar_hash_transacao(row):
                            data_str = row["Data"].strftime("%Y-%m-%d") if hasattr(row["Data"], 'strftime') else str(row["Data"])
                            chave = f"{data_str}|{row['Descri√ß√£o']}|{row['Valor']}"
                            return hashlib.md5(chave.encode()).hexdigest()
                        
                        def nao_esta_excluida(row):
                            hash_transacao = gerar_hash_transacao(row)
                            return hash_transacao not in transacoes_excluidas
                        
                        df = df[df.apply(nao_esta_excluida, axis=1)]
                except:
                    pass  # Em caso de erro, manter todas as transa√ß√µes
            
            # Calcular saldos por origem
            saldos_info = {}
            for origem in df['Origem'].unique():
                df_origem = df[df['Origem'] == origem]
                saldo = df_origem['Valor'].sum()
                saldos_info[origem] = {
                    'saldo': saldo,
                    'tipo': 'credit_card' if 'fatura' in origem.lower() or 'nubank' in origem.lower() else 'checking'
                }
        else:
            saldos_info = {}
        
        return saldos_info, df
    
    return ExceptionHandler.safe_execute(
        func=_load_data,
        error_handler=ExceptionHandler.handle_generic_error,
        default_return=({}, pd.DataFrame())
    )

# Fun√ß√µes para descri√ß√µes personalizadas
def gerar_hash_transacao(row):
    """Gera um hash √∫nico para identificar uma transa√ß√£o de forma consistente"""
    data_str = row["Data"].strftime("%Y-%m-%d") if hasattr(row["Data"], 'strftime') else str(row["Data"])
    chave = f"{data_str}|{row['Descri√ß√£o']}|{row['Valor']}"
    return hashlib.md5(chave.encode()).hexdigest()

def carregar_descricoes_personalizadas():
    """Carrega o cache de descri√ß√µes personalizadas do usu√°rio"""
    descricoes_file = get_descricoes_personalizadas_file()
    if os.path.exists(descricoes_file):
        try:
            with open(descricoes_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}

def obter_descricao_personalizada(row):
    """Obt√©m a descri√ß√£o personalizada de uma transa√ß√£o, se existir"""
    descricoes = carregar_descricoes_personalizadas()
    hash_transacao = gerar_hash_transacao(row)
    return descricoes.get(hash_transacao, "Nenhuma descri√ß√£o dispon√≠vel")

# Fun√ß√£o para formatar DataFrame com descri√ß√µes personalizadas
def formatar_df_com_descricoes(df):
    """Formata o DataFrame adicionando descri√ß√µes personalizadas e removendo coluna Id"""
    if df.empty:
        return df
    
    # Criar c√≥pia do DataFrame
    df_formatado = df.copy()
    
    # Aplicar formata√ß√£o monet√°ria
    df_formatado = formatar_df_monetario(df_formatado)
    
    # Adicionar coluna de descri√ß√£o personalizada (renomeada para "Nota")
    df_formatado["Nota"] = df_formatado.apply(obter_descricao_personalizada, axis=1)
    
    # Reordenar colunas: Data ‚Üí Descri√ß√£o ‚Üí Valor ‚Üí Nota ‚Üí outras
    colunas_desejadas = []
    
    for col in df_formatado.columns:
        if col.lower() not in ['id', 'index']:  # Excluir colunas de Id
            colunas_desejadas.append(col)
    
    # Criar nova ordem das colunas
    colunas_ordenadas = []
    
    # 1. Adicionar Data (se existir)
    if "Data" in colunas_desejadas:
        colunas_ordenadas.append("Data")
    
    # 2. Adicionar Descri√ß√£o (se existir)
    if "Descri√ß√£o" in colunas_desejadas:
        colunas_ordenadas.append("Descri√ß√£o")
    
    # 3. Adicionar Valor (se existir)
    if "Valor" in colunas_desejadas:
        colunas_ordenadas.append("Valor")
    elif "ValorFormatado" in colunas_desejadas:
        colunas_ordenadas.append("ValorFormatado")
    
    # 4. Adicionar Nota (se existir)
    if "Nota" in colunas_desejadas:
        colunas_ordenadas.append("Nota")
    
    # 5. Adicionar demais colunas na ordem original
    for col in colunas_desejadas:
        if col not in colunas_ordenadas:
            colunas_ordenadas.append(col)
    
    return df_formatado[colunas_ordenadas]

# Sidebar - Configura√ß√µes
st.sidebar.header("‚öôÔ∏è Configura√ß√µes")

# Bot√£o de Sair
st.sidebar.markdown("---")  # Separador visual
if st.sidebar.button('üö™ Sair', help="Fazer logout da aplica√ß√£o", type="primary"):
    st.session_state.clear()
    st.rerun()

# Carregar dados principais
usuario = st.session_state.get('usuario', 'default')

# Migra√ß√£o autom√°tica de dados legados para o usu√°rio atual
try:
    from utils.user_data_manager import user_data_manager
    migrated_files = user_data_manager.copy_legacy_data_to_user(usuario)
    if migrated_files:
        st.info(f"üì¶ **Migra√ß√£o autom√°tica**: {len(migrated_files)} arquivos foram migrados para seu perfil de usu√°rio.")
        with st.expander("Ver arquivos migrados"):
            for file in migrated_files:
                st.text(f"‚Ä¢ {file}")
except Exception as e:
    st.error(f"Erro na migra√ß√£o autom√°tica: {e}")

saldos_info, df = carregar_dados_home(usuario)

# Verificar se h√° dados
if df.empty:
    st.warning("üì≠ Nenhuma transa√ß√£o encontrada nos arquivos OFX!")
    st.info("üí° **Como adicionar dados:**")
    st.markdown("""
    1. üìÅ Coloque seus extratos (.ofx) na pasta `extratos/`
    2. üí≥ Coloque suas faturas de cart√£o (.ofx) na pasta `faturas/`
    3. üîÑ Clique em "Atualizar Dados" na barra lateral
    """)
    
    # Mostrar resumo dos arquivos dispon√≠veis
    ofx_reader = get_ofx_reader()
    resumo = ofx_reader.get_resumo_arquivos()
    
    col1, col2 = st.columns(2)
    with col1:
        st.metric("üìÑ Extratos Dispon√≠veis", resumo['total_extratos'])
    with col2:
        st.metric("üí≥ Faturas Dispon√≠veis", resumo['total_faturas'])
    
    st.stop()

# Dashboard principal
st.subheader("üìä Resumo Financeiro")

# Calcular resumo financeiro
resumo = calcular_resumo_financeiro(df)

# M√©tricas principais
col1, col2, col3, col4 = st.columns(4)

with col1:
    st.metric(
        "üí∞ Receitas", 
        formatar_valor_monetario(resumo["receitas"]),
        delta=None
    )

with col2:
    st.metric(
        "üí∏ Despesas", 
        formatar_valor_monetario(abs(resumo["despesas"])),
        delta=None
    )

with col3:
    saldo_liquido = resumo["saldo"]
    delta_color = "normal" if saldo_liquido >= 0 else "inverse"
    st.metric(
        "üí≥ Saldo L√≠quido", 
        formatar_valor_monetario(saldo_liquido),
        delta=None
    )

with col4:
    st.metric(
        "üìà Total de Transa√ß√µes", 
        len(df),
        delta=None
    )

# Filtros
st.subheader("üîç Filtros")
col1, col2 = st.columns(2)

with col1:
    data_inicio, data_fim = filtro_data(df)

with col2:
    categorias_selecionadas = filtro_categorias(df)

# Aplicar filtros
df_filtrado = aplicar_filtros(df, data_inicio, data_fim, categorias_selecionadas)

if df_filtrado.empty:
    st.warning("üîç Nenhuma transa√ß√£o encontrada com os filtros aplicados.")
    st.stop()

# Gr√°ficos
st.subheader("üìà An√°lises")

# Nova se√ß√£o: Insights Inteligentes com IA (Backend V2)
if backend_v2 and not df_filtrado.empty:
    with st.expander("ü§ñ Insights Inteligentes com IA", expanded=True):
        try:
            transacao_service = backend_v2['transacao_service']
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**üéØ An√°lises Personalizadas**")
                
                # Categoriza√ß√£o autom√°tica de transa√ß√µes recentes
                if st.button("üè∑Ô∏è Recategorizar automaticamente"):
                    with st.spinner("Analisando transa√ß√µes com IA..."):
                        resultado = transacao_service.processar_categorizacao_ai(usuario)
                        if resultado.get('success'):
                            st.success(f"‚úÖ {resultado.get('categorized_count', 0)} transa√ß√µes recategorizadas!")
                            st.rerun()
                        else:
                            st.warning(f"‚ö†Ô∏è {resultado.get('error', 'Erro na categoriza√ß√£o')}")
                
                # Detec√ß√£o de anomalias
                if st.button("üîç Detectar anomalias"):
                    with st.spinner("Detectando padr√µes an√¥malos..."):
                        anomalias = transacao_service.detectar_anomalias_usuario(usuario)
                        if anomalias:
                            st.warning(f"‚ö†Ô∏è {len(anomalias)} anomalias detectadas")
                            for anomalia in anomalias[:3]:  # Mostrar apenas as 3 primeiras
                                st.write(f"‚Ä¢ {anomalia.get('descricao', 'N/A')}: {anomalia.get('motivo', 'N/A')}")
                        else:
                            st.success("‚úÖ Nenhuma anomalia detectada")
            
            with col2:
                st.write("**üìä Relat√≥rios Avan√ßados**")
                
                # An√°lise de tend√™ncias
                if st.button("üìà Gerar an√°lise de tend√™ncias"):
                    with st.spinner("Gerando insights de tend√™ncias..."):
                        tendencias = transacao_service.gerar_relatorio_tendencias(usuario)
                        if tendencias.get('success'):
                            st.success("‚úÖ An√°lise de tend√™ncias gerada!")
                            # Mostrar algumas m√©tricas principais
                            metricas = tendencias.get('metricas', {})
                            if metricas:
                                st.json({
                                    "Crescimento mensal": f"{metricas.get('crescimento_mensal', 0):.1f}%",
                                    "Categoria dominante": metricas.get('categoria_dominante', 'N/A'),
                                    "Padr√£o de gastos": metricas.get('padrao_gastos', 'N/A')
                                })
                        else:
                            st.error(f"‚ùå {tendencias.get('error', 'Erro na an√°lise')}")
                
                # Health check do sistema
                st.write("**üè• Status do Sistema**")
                try:
                    monitor = backend_v2['monitor']
                    health = monitor.get_system_health()
                    if health.get('healthy'):
                        st.success(f"‚úÖ Sistema saud√°vel ({health.get('total_connections', 0)} conex√µes)")
                    else:
                        st.warning("‚ö†Ô∏è Sistema com problemas")
                except:
                    st.info("‚ùì Status indispon√≠vel")
                    
        except Exception as e:
            st.error(f"‚ùå Erro ao carregar insights: {str(e)}")

st.markdown("---")

# Primeira linha: Distribui√ß√£o por Categoria
col1, col2 = st.columns(2)

with col1:
    # Gr√°fico de categorias (apenas despesas)
    if "Categoria" in df_filtrado.columns:
        # Filtrar apenas transa√ß√µes negativas (despesas)
        df_despesas = df_filtrado[df_filtrado["Valor"] < 0]
        
        if not df_despesas.empty:
            categoria_resumo_despesas = df_despesas.groupby("Categoria")["Valor"].sum().reset_index()
            categoria_resumo_despesas["ValorAbs"] = categoria_resumo_despesas["Valor"].abs()
            categoria_resumo_despesas = categoria_resumo_despesas.sort_values("ValorAbs", ascending=False)
            
            fig_cat_despesas = px.pie(
                categoria_resumo_despesas, 
                names="Categoria", 
                values="ValorAbs",
                title="Distribui√ß√£o por Categoria (Despesas)",
                color_discrete_sequence=px.colors.qualitative.Set3
            )
            st.plotly_chart(fig_cat_despesas, use_container_width=True)
        else:
            st.info("üìä Nenhuma despesa encontrada no per√≠odo selecionado.")

with col2:
    # Gr√°fico de categorias (apenas receitas)
    if "Categoria" in df_filtrado.columns:
        # Filtrar apenas transa√ß√µes positivas (receitas)
        df_receitas = df_filtrado[df_filtrado["Valor"] > 0]
        
        if not df_receitas.empty:
            categoria_resumo_receitas = df_receitas.groupby("Categoria")["Valor"].sum().reset_index()
            categoria_resumo_receitas = categoria_resumo_receitas.sort_values("Valor", ascending=False)
            
            fig_cat_receitas = px.pie(
                categoria_resumo_receitas, 
                names="Categoria", 
                values="Valor",
                title="Distribui√ß√£o por Categoria (Receitas)",
                color_discrete_sequence=px.colors.qualitative.Pastel
            )
            st.plotly_chart(fig_cat_receitas, use_container_width=True)
        else:
            st.info("üìä Nenhuma receita encontrada no per√≠odo selecionado.")

# Segunda linha: Evolu√ß√£o Temporal
st.markdown("---")
if "Data" in df_filtrado.columns:
    df_temp = df_filtrado.copy()
    df_temp["AnoMes"] = df_temp["Data"].dt.to_period("M").astype(str)
    evolucao = df_temp.groupby("AnoMes")["Valor"].sum().reset_index()
    
    fig_evolucao = px.line(
        evolucao, 
        x="AnoMes", 
        y="Valor",
        title="üìà Evolu√ß√£o Mensal do Saldo",
        markers=True,
        line_shape="spline"
    )
    fig_evolucao.update_layout(
        xaxis_title="Per√≠odo",
        yaxis_title="Valor (R$)",
        showlegend=False
    )
    st.plotly_chart(fig_evolucao, use_container_width=True)

# Tabela de transa√ß√µes com abas por categoria
st.subheader("üìã Transa√ß√µes do Per√≠odo")

# Obter categorias dispon√≠veis no per√≠odo filtrado
if not df_filtrado.empty:
    categorias_periodo = sorted(df_filtrado["Categoria"].unique())
    
    # Criar lista de abas: "Todas" + categorias espec√≠ficas
    abas_disponiveis = ["üìä Todas"] + [f"üè∑Ô∏è {cat}" for cat in categorias_periodo]
    
    # Criar abas usando st.tabs
    tabs = st.tabs(abas_disponiveis)
    
    with tabs[0]:  # Aba "Todas"
        st.markdown("**Todas as transa√ß√µes do per√≠odo selecionado**")
        
        # Mostrar resumo
        total_transacoes = len(df_filtrado)
        valor_total = df_filtrado["Valor"].sum()
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üíº Total", total_transacoes)
        with col2:
            st.metric("üí∞ Saldo", formatar_valor_monetario(valor_total))
        with col3:
            receitas_count = len(df_filtrado[df_filtrado["Valor"] > 0])
            despesas_count = len(df_filtrado[df_filtrado["Valor"] < 0])
            st.metric("üìàüìâ R/D", f"{receitas_count}/{despesas_count}")
        
        # Tabela formatada com descri√ß√µes personalizadas
        df_display_todas = formatar_df_com_descricoes(df_filtrado.head(50))
        st.dataframe(
            df_display_todas,
            use_container_width=True,
            height=400
        )
        
        if len(df_filtrado) > 50:
            st.caption(f"üìÑ Exibindo 50 de {len(df_filtrado)} transa√ß√µes (ordenadas por data mais recente)")
    
    # Abas para cada categoria
    for i, categoria in enumerate(categorias_periodo, 1):
        with tabs[i]:
            # Filtrar transa√ß√µes da categoria
            df_categoria = df_filtrado[df_filtrado["Categoria"] == categoria]
            
            st.markdown(f"**Transa√ß√µes da categoria: {categoria}**")
            
            # Mostrar resumo da categoria
            total_cat = len(df_categoria)
            valor_cat = df_categoria["Valor"].sum()
            receitas_cat = len(df_categoria[df_categoria["Valor"] > 0])
            despesas_cat = len(df_categoria[df_categoria["Valor"] < 0])
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üíº Transa√ß√µes", total_cat)
            with col2:
                st.metric("üí∞ Total", formatar_valor_monetario(valor_cat))
            with col3:
                if receitas_cat > 0 and despesas_cat > 0:
                    st.metric("üìàüìâ R/D", f"{receitas_cat}/{despesas_cat}")
                elif receitas_cat > 0:
                    st.metric("üìà Receitas", receitas_cat)
                else:
                    st.metric("üìâ Despesas", despesas_cat)
            
            if not df_categoria.empty:
                # Tabela formatada da categoria com descri√ß√µes personalizadas
                df_display_cat = formatar_df_com_descricoes(df_categoria.head(50))
                st.dataframe(
                    df_display_cat,
                    use_container_width=True,
                    height=400
                )
                
                if len(df_categoria) > 50:
                    st.caption(f"üìÑ Exibindo 50 de {len(df_categoria)} transa√ß√µes desta categoria")
            else:
                st.info("üì≠ Nenhuma transa√ß√£o encontrada nesta categoria para o per√≠odo selecionado.")

else:
    st.warning("üîç Nenhuma transa√ß√£o encontrada com os filtros aplicados.")
    st.info("üí° Ajuste os filtros de data ou categoria para ver as transa√ß√µes.")

# Informa√ß√µes sobre arquivos OFX
with st.expander("üìÅ Informa√ß√µes dos Arquivos OFX"):
    ofx_reader = get_ofx_reader()
    resumo = ofx_reader.get_resumo_arquivos()
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Extratos:**")
        st.write(f"Total: {resumo['total_extratos']} arquivos")
        if resumo['periodo_extratos']['inicio']:
            st.write(f"Per√≠odo: {resumo['periodo_extratos']['inicio']} a {resumo['periodo_extratos']['fim']}")
    
    with col2:
        st.write("**Faturas:**")
        st.write(f"Total: {resumo['total_faturas']} arquivos")
        if resumo['periodo_faturas']['inicio']:
            st.write(f"Per√≠odo: {resumo['periodo_faturas']['inicio']} a {resumo['periodo_faturas']['fim']}")
